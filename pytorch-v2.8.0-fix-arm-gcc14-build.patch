diff -Nuarp pytorch-v2.8.0.orig/aten/src/ATen/cpu/vec/sve/vec_bfloat16.h pytorch-v2.8.0/aten/src/ATen/cpu/vec/sve/vec_bfloat16.h
--- pytorch-v2.8.0.orig/aten/src/ATen/cpu/vec/sve/vec_bfloat16.h	2025-08-07 01:08:00.000000000 +0800
+++ pytorch-v2.8.0/aten/src/ATen/cpu/vec/sve/vec_bfloat16.h	2025-08-07 14:14:42.204501789 +0800
@@ -220,6 +220,10 @@ class Vectorized<BFloat16> {
   Vectorized<BFloat16> le(const Vectorized<BFloat16>& other) const;
 };
 
+#if defined(__GNUC__) && __GNUC__ == 14
+// Workaround for gcc-14.2.0 ICE during RTL pass: vregs when compiling for SVE
+__attribute__((optimize("no-tree-vectorize")))
+#endif
 inline std::tuple<Vectorized<float>, Vectorized<float>> convert_bfloat16_float(
     const Vectorized<c10::BFloat16>& a) {
   static_assert(
diff -Nuarp pytorch-v2.8.0.orig/aten/src/ATen/native/cpu/Activation.cpp pytorch-v2.8.0/aten/src/ATen/native/cpu/Activation.cpp
--- pytorch-v2.8.0.orig/aten/src/ATen/native/cpu/Activation.cpp	2025-08-07 01:08:00.000000000 +0800
+++ pytorch-v2.8.0/aten/src/ATen/native/cpu/Activation.cpp	2025-08-07 14:16:02.936177964 +0800
@@ -26,6 +26,10 @@ namespace at::native {
 
 namespace {
 
+#if defined(__GNUC__) && __GNUC__ == 14 && defined(__aarch64__) && !defined(__ARM_FEATURE_SVE)
+// Workaround for gcc-14.2.0 ICE during RTL pass: expand when compiling for NEON
+__attribute__((optimize("no-tree-vectorize")))
+#endif
 static void log_sigmoid_cpu_kernel(TensorBase &output, TensorBase &buffer, const TensorBase &input) {
   if (at::isReducedFloatingType(input.scalar_type())) {
     AT_DISPATCH_REDUCED_FLOATING_TYPES(input.scalar_type(), "log_sigmoid_cpu", [&]() {
diff -Nuarp pytorch-v2.8.0.orig/aten/src/ATen/native/cpu/Unfold2d.cpp pytorch-v2.8.0/aten/src/ATen/native/cpu/Unfold2d.cpp
--- pytorch-v2.8.0.orig/aten/src/ATen/native/cpu/Unfold2d.cpp	2025-08-07 01:08:00.000000000 +0800
+++ pytorch-v2.8.0/aten/src/ATen/native/cpu/Unfold2d.cpp	2025-08-07 14:02:59.465445387 +0800
@@ -169,6 +169,10 @@ static void unfolded2d_acc_channels_last
 
 /* note: due to write issues, this one cannot be parallelized as well as
  * unfolded2d_copy */
+#if defined(__GNUC__) && __GNUC__ == 14 && defined(__ARM_FEATURE_SVE)
+// Workaround for gcc-14.2.0 ICE during RTL pass: vregs when compiling for SVE
+__attribute__((optimize("no-tree-vectorize")))
+#endif
 void unfolded2d_acc_kernel(
     ScalarType dtype,
     void *finput_data,
